[{"title":"Test post","url":"/test-post/"},{"title":"Dynamic environment in your static Angular application","url":"/dynamic-environment-in-your-static-angular-application/","content":"I keep hitting the same problem when building Angular applications. Environment settings! They are easy to set up in development, but as you target different environments, the old \"one file per environment\" really doesn't cut it. I don't want to rebuild my application just to deploy to production and if it's in a container? Pfft, good luck! I've solved this problem a few different ways in the past and I've just solved it again. But this time, it didn't feel quite so hacky, so I thought I'd post about it.\n\n<!-- more -->\n\n## Problem\nAngular CLI provides an `environment.ts` for storing your global settings and you can select which environment file to use when you build. I want to build my application once and then deploy to different environments without rebuilding, however I can't change my environment settings on deploy or through environment variables. There are a few reasons I don't want to rebuild.\n1. I want to test in staging and then redeploy the artifact to production\n2. I want to run it from a container\n\n## Solution\nOk, so this is not a new problem and it has been reasonably solved on server side deployments a few ways:\n1. Environment variables / web.config / appsettings.json - config is easily overridden in place and is often used for server config settings.\n2. Rewrite on deploy - the deployment script itself can overwrite settings as it is deployed to configure the environment it is deploying to.\n\n### Option 1: Inject bootstrap settings into the index.html\nThis was my first attempt at solving the problem. I added a comment in the index.html and created an MVC endpoint to load the index.html file, replace the comment with a script block to create a settings object and return the updated html page. It was good for keeping the number of requests down, but it felt a bit hacky.\n\n### Option 2: A separate bootstrap script file\nThis approach was inspired by [this post](https://www.jvandemo.com/how-to-configure-your-angularjs-application-using-environment-variables/). The basic idea is to pull a separate self-executing script that contains our bootstrap settings from the `index.html`.\n\n```markup\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>My Awesome Angular app</title>\n    <base href=\"/\">\n    <meta name=\"viewport\" \n          content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\n    <!-- Load environment variables -->\n    <script src=\"assets/bootstrap.js\"></script>  \n  </head>\n  <body>\n    <app-root></app-root>\n  </body>\n</html>\n```\n\nNext, create the `bootstrap.js` file in your assets folder. It should look something like this:\n```javascript\n(function (window) {\n  window.bootstrapSettings = {\n    apiUrl: 'https://localhost:44384',\n    production: false,\n  };\n}(this));\n```\n\nWhen the angular app loads, we now have a bootstrap object available to pull settings from. In this case, I can reference `window.bootstrapSettings.apiUrl` to find my api location, but I'm trying to use `environment.apiUrl`.\n\nNext, we need to update `environment.ts` to bring in the bootstrap settings.\n\n```typescript\nexport const environment = Object.assign({\n    production: false,\n  },\n  (window as any).bootstrapSettings);\n```\n\nAt this point, we can build once and serve from different static sites by simply applying a different `assets/bootstrap.js` file with the new settings during deployment.\n\nThis is good, but we're serving from dotnet core, so we can do better. (If you're using node, the idea is not much different). The basic idea is to avoid serving the static bootstrap file and instead, send a bootstrap file based on our appsettings file, which we can easily override from our environment (web app, container, etc) using the middleware below.\n\n```csharp\npublic class EnvironmentBootstrap\n{\n    public string apiUrl { get; set; }\n}\n\npublic static class EnvironmentBootstrapExtensions\n{\n    public static IApplicationBuilder UseEnvironmentBootstrap(\n\t\tthis IApplicationBuilder builder, string path)\n    {\n        return builder.UseMiddleware<EnvironmentBootstrapMiddleware>(path);\n    }\n}\n\npublic class EnvironmentBootstrapMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly EnvironmentBootstrap _environment;\n    private readonly string _endpointPath;\n\n    public EnvironmentBootstrapMiddleware(\n    \tRequestDelegate next, \n        IOptions<EnvironmentBootstrap> options, \n        string path)\n    {\n        _next = next;\n        _endpointPath = path;\n        _environment = options.Value;\n    }\n\n    public async Task Invoke(HttpContext httpContext)\n    {\n        // Short circuit on request for bootstrap.js\n        if (httpContext.Request.Path\n            .Equals(_endpointPath, StringComparison.Ordinal))\n        {\n            httpContext.Response.ContentType = \"application/javascript\";\n            await httpContext.Response.WriteAsync(\n            \t\"(function (window) { window.bootstrapSettings = \" +\n            \tJsonConvert.SerializeObject(_environment) + \n            \t\";}(this));\");\n        }\n        else\n            // Pass to next item in the pipeline\n            await _next.Invoke(httpContext);\n    }\n}\n```\n\nFinally, activate the pipeline in the Startup.cs file:\n```csharp\npublic class Startup\n{\n    public void ConfigureServices(IServiceCollection services)\n    {\n        // ...\n        services.Configure<EnvironmentBootstrap>(\n            Configuration.GetSection(\"client\"));\n        // ...\n    }\n                    \n    public void Configure(IApplicationBuilder app)\n    {\n        // ...\n        // Bootstrap the bootstrap.js file ahead of UseStaticFiles\n        app.UseEnvironmentBootstrap(\"/assets/bootstrap.js\");\n        app.UseStaticFiles();\n        app.UseSpaStaticFiles();\n        // ...\n    }\n}\n```\n\nThat's it! The project can now be built once and deployed to different environments, with angular client environment settings available to be configured from the environment itself. For an Azure Web app, set an Application Setting 'client:apiUrl' to override the client's `apiUrl` environment setting.\n\nWhat do you think? Is there a better solution? What do you like or dislike about this approach?","tags":["dotnet","angular"]},{"title":"Automatic HTTPS on Kubernetes","url":"/automatic-https-on-kubernetes/","content":"This post starts with a slight regret that I didn't get Ghost running on a Web App.  One of the brilliant parts of a Web App is that you can force all requests over HTTPS with the click of a button. Of course, I'd still need to organise a certificate for my domain. Hold on, let me stop and back up a minute.\n\n<!-- more -->\n\nWhat the heck is this HTTPS and certificate stuff? Basically, HTTPS will guarantee that the communication between the client and server can't be read or changed by anyone between the client and server. So, usernames and passwords are safe to send. While that's important, it's probably more important that your pages cannot be changed either. It's a bit like a message written in code with the king's seal. Since the code (HTTPS) is known to you and the king, you know it cannot be read. The seal (certificate) proves the authenticity.\n\nAs I set out on this adventure, it looks like I need cert-manager and the best way to install this appears to be to use helm, which I installed with Chocolatey.\n\nchoco install kubernetes-helm\nhelm init\nFirst steps\nWe are going to install cert-manager which will perform all of the magic of fetching certificates and storing them for use in our various services. We need to set up the config for cert-manager, so that we can provide the link to Lets Encrypt. Save the following in a file, say issuer.yaml, and run 'kubectl apply -f issuer.yaml' to apply. (Make sure you update with your email first!)\n\n```yaml\napiVersion: certmanager.k8s.io/v1alpha1\nkind: ClusterIssuer\nmetadata:\n  name: letsencrypt-prod\nspec:\n  acme:\n    server: https://acme-v02.api.letsencrypt.org/directory    \n    email: youremail@gmail.com\n    privateKeySecretRef:\n      name: letsencrypt-prod\n    http01: {}\n```\n\nInstalling cert manager\nkubectl apply -f \\\n    https://raw.githubusercontent.com/jetstack/cert-manager/release-0.6/deploy/manifests/00-crds.yaml\n\nhelm install --name cert-manager --namespace ingress \\\n    --set ingressShim.defaultIssuerName=letsencrypt-prod \n    --set ingressShim.defaultIssuerKind=ClusterIssuer \n    stable/cert-manager\nI ran into issues installing cert-manager with a 'cluster-admin' not found error. I found instructions on this page[4] which helped me create a cluster admin role, create a service account and assign tiller to it.\n\nInstalling nginx-ingress\nThe next step is to configure an Ingress to manage the TLS endpoint, that is to manage my HTTPS endpoint with certificate connected to my domain. Without this step, I found I could set up my Ingress entry, but the address would stay empty.\n\nhelm install stable/nginx-ingress \\\n    --name nginx \\\n    --set rbac.create=true \\\n    --namespace ingress\nOnce installed, I can see a LoadBalancer entry which has my External IP on it.\n\nUpdate the Service\nIn the previous post, we set the service up as a LoadBalancer type. We don't need that any more since we have a new IP on our LoadBalancer nginx-ingress service. Update the service.yaml and change LoadBalancer to a NodePort and run 'kubectl apply -f service.yaml'. This will make sure we can only access our service through our TLS ingress service.\n\nGenerate Certificate and Ingress for Service\nApply the following updates to the kubernetes cluster.\n\n```yaml\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: anthonyison-ingress\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    certmanager.k8s.io/cluster-issuer: letsencrypt-prod\nspec:\n  tls:\n  - hosts:\n    - anthonyison.com\n    secretName: anthonyison-crt\n  rules:\n  - host: anthonyison.com\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: anthonyison\n          servicePort: 80\napiVersion: certmanager.k8s.io/v1alpha1\nkind: Certificate\nmetadata:\n  name: anthonyison-crt\nspec:\n  secretName: anthonyison-crt\n  dnsNames:\n  - anthonyison.com\n  acme:\n    config:\n    - http01:\n        ingressClass: nginx\n      domains:\n      - anthonyison.com\n  issuerRef:\n    name: letsencrypt-prod\n    kind: ClusterIssuer\n```\n\nThat's it!  Hit your domain and confirm that https is working. You should be able to click on the padlock in the address bar and click on Certificate to see the details. You should see a certificate issued by Lets Encrypt to your domain name.\n\nSo, I started off with some regret that I wasn't running in a Web App. While it took quite a while to work through many of the issues that showed up along the way, it is actually pretty easy once it's set up, and furthermore, I don't have to think about my certificates ever again. I think maybe it's not as bad as I thought. No regrets, right?\n\nReferences:\n\n[1]: https://itnext.io/automated-tls-with-cert-manager-and-letsencrypt-for-kubernetes-7daaa5e0cae4 \"Automated TLS with Cert Manager and Lets Encrypt for Kubernetes\"\n\n[2]: https://akomljen.com/get-automatic-https-with-lets-encrypt-and-kubernetes-ingress/ \"Get automatic HTTPS with Lets Encrpyt and Kubernetes Ingress\"\n\n[3]: https://runnable.com/blog/how-to-use-lets-encrypt-on-kubernetes \"How to use Lets Encrypt on Kubernetes (without Cert Manager)\"\n\n[4]: https://docs.bitnami.com/azure/get-started-aks/ \"Configuring AKS\"\n\n[5]: https://dzone.com/articles/secure-your-kubernetes-services-using-cert-manager \"Secure your Kubernetes Services using Cert Manager\"","tags":["kubernetes"]},{"title":"Running Ghost on Kubernetes on Azure","url":"/running-ghost-on-kubernetes-on-azure/","content":"In my [previous post](/creating-a-blog-with-ghost/), I was looking into a few options for running my blog. I think at this time, I'm going to keep it on Azure because I can run it for free. I suspect I would make a different choice if not for my bonus credits. I will need some benchmark figures to choose a provider, however kubernetes should give me the platform I need to change in the future if necessary.\n\n<!-- more -->\n\nI have a basic level of understanding of how kubernetes hangs together and would love to hear your feedback if you would do things differently. The basic idea is to run a ghost container and provide persistent storage for the content. In the future, I would like to use nginx to reverse proxy incoming traffic and to provide HTTPS for my site.\n\nI have used AKS to generate a kubernetes cluster and my kubectl is configured to connect to it. First, I need to configure my storage. For this, I use a yaml file.\n\n```yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: anthonyison-content\nspec:\n  accessModes:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi\n  storageClassName: default\n```\n\nUsing `kubectl apply -f volume.yaml` we can generate the volume claim to be used in the next step. Next, we will generate a deployment for the the ghost container, linking it to the anthonyison-content volume.\n\n```yaml\napiVersion: apps/v1beta1\nkind: Deployment\nmetadata:\n  name: anthonyison\n  labels:\n    app: anthonyison\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: anthonyison\n  template:\n    metadata:\n      labels:\n        app: anthonyison\n    spec:\n      containers:\n      - name: anthonyison\n        image: ghost:2.9.1-alpine\n        imagePullPolicy: Always\n        ports:\n        - containerPort: 2368\n        env:\n        - name: url\n          value: http://anthonyison.com\n        volumeMounts:\n        - mountPath: /var/lib/ghost/content\n          name: content\n      volumes:\n      - name: content\n        persistentVolumeClaim:\n          claimName: anthonyison-content\n```\n\nSo now we have a ghost container running in Kubernetes with an external mounted volume for storing content. However, it's not exposed as yet. We do that with a Service. The `service.yaml` is below.\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: anthonyison\nspec:\n  type: LoadBalancer\n  selector:\n    app: anthonyison\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 2368\n```\n\nAnd that's actually all there is to it. By running `kubectl get services` you can see the External IP. If you put that in the browser, you will go to the new blog. Better still, put the IP into your DNS A record, and your domain name will direct to the new site.","tags":["ghost","kubernetes","azure"]},{"title":"Creating a blog with Ghost","url":"/creating-a-blog-with-ghost/","content":"There seems to come a time in a software developer's life where you look at creating a blog. It's that time for me. I want a place where I can write up some of my experiments for later reference, and if that can help others along the way, all the better!\n\n<!-- more -->\n\n# Considerations\n1. I don't want to pay anything. I really don't want to break the bank with this project. If I can pay nothing, I will. This puts [Azure](https://azure.com) squarely in the front seat because I have $70 a month to spend there.\n2. Easy to use. I don't want to spend ages messing with this project, or debugging issues.\n3. Broad application / reusable. It would be great if this thing can be used for more than just this blog. If I can host other sites or blogs on the same infrastructure, that would be kinda handy.\n4. Preferably something I want to learn. Cause, you know. What's the point otherwise?\n\nAt first, I had thought I'd be using [Wordpress](https://wordpress.org) and I wasn't really looking forward to that. On the upside, there are wordpress containers around and I was pretty keen to run it in a container.\n\nAfter a quick email with [Thiago](https://passos.com.au), I started looking at [Ghost](https://ghost.org). Once I knew it was there, I noticed that many of the blogs I read, including [Troy Hunt](https://www.troyhunt.com), are powered by Ghost. With little more than that meagre planning, it was time to get started.\n# Attempt 1: Azure Web apps\nFirstly, I needed a place to host it. I'm an Azure guy, so I started there. It seemed to be straight forward enough. A ghost container, wrapped in a Web App, running on Linux, volume mapped to a Azure File storage. I ran it locally and it worked perfectly. Once installed on Azure, I found the database just wouldn't load up correctly, giving Migration errors, saying that the database was locked.\n\nFirst attempt foiled!\n# Attempt 2: Google GKE\nMy next attempt was to spin it up on GKE on to [Google cloud](https://cloud.google.com). [Kubernetes](https://kubernetes.io) seemed to be a bit of overkill for what I was trying, but Google made that super easy, and it pretty much \"just worked\".\n\nThat left me with the question, what about AKS on Azure?\n# Attempt 3: Azure AKS\nI've never created an AKS cluster. I mean, I've wanted to. Who hasn't? The thing is, I've never actually clicked the Go button. So, I guess it's time. It was easy enough to configure as well and then I clicked Create and waited. I waited and then I waited some more. I went looking for any events showing that something was happening, but couldn't see anything. So I tried again and this time, it worked.\n\nIt spun up easy enough and with minor changes to the PersistentVolumeClaim, it just worked as well, albeit it a bit slower than GKE, which was odd because I had double the resources on Azure.\n# So, now what?\nAlright, so now I seem to be on the kubernetes train. Even writing it now, it seems kinda crazy to spin up a kubernetes cluster to run a blog that is probably only going to have me as traffic. But it is expandable. There are a couple of sites I want to host. They're currently in containers on Azure Web apps, but should move across easy enough.\n\nI'm still not sure of cost. I will run both solutions for a couple of days and have a look at what charges come through. I hadn't planned to move from Azure at this time. That's where I have the most experience.\n# Next steps\n1. Run some performance and pricing measures to compare GKE vs AKS and decide where my blog will stay.\n2. Write up the technical steps for creating the blog.\n3. Enable the site to run [HTTPS](https://www.troyhunt.com/the-6-step-happy-path-to-https/) with [Let's Encrypt](https://letsencrypt.org) certificates.","tags":["ghost"]}]