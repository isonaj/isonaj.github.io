{"meta":{"title":"Anthony Ison","subtitle":"Software development and DevOps. Bringing solutions to life.","description":null,"author":"Anthony Ison","url":"http://anthonyison.com","root":"/"},"pages":[],"posts":[{"title":"Test post","slug":"test-post","date":"2019-05-02T12:45:13.000Z","updated":"2019-05-02T12:45:13.433Z","comments":true,"path":"test-post/","link":"","permalink":"http://anthonyison.com/test-post/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Dynamic environment in your static Angular application","slug":"dynamic-environment-in-your-static-angular-application","date":"2019-04-24T14:00:00.000Z","updated":"2019-05-02T11:58:42.547Z","comments":true,"path":"dynamic-environment-in-your-static-angular-application/","link":"","permalink":"http://anthonyison.com/dynamic-environment-in-your-static-angular-application/","excerpt":"I keep hitting the same problem when building Angular applications. Environment settings! They are easy to set up in development, but as you target different environments, the old “one file per environment” really doesn’t cut it. I don’t want to rebuild my application just to deploy to production and if it’s in a container? Pfft, good luck! I’ve solved this problem a few different ways in the past and I’ve just solved it again. But this time, it didn’t feel quite so hacky, so I thought I’d post about it.","text":"I keep hitting the same problem when building Angular applications. Environment settings! They are easy to set up in development, but as you target different environments, the old “one file per environment” really doesn’t cut it. I don’t want to rebuild my application just to deploy to production and if it’s in a container? Pfft, good luck! I’ve solved this problem a few different ways in the past and I’ve just solved it again. But this time, it didn’t feel quite so hacky, so I thought I’d post about it. ProblemAngular CLI provides an environment.ts for storing your global settings and you can select which environment file to use when you build. I want to build my application once and then deploy to different environments without rebuilding, however I can’t change my environment settings on deploy or through environment variables. There are a few reasons I don’t want to rebuild. I want to test in staging and then redeploy the artifact to production I want to run it from a container SolutionOk, so this is not a new problem and it has been reasonably solved on server side deployments a few ways: Environment variables / web.config / appsettings.json - config is easily overridden in place and is often used for server config settings. Rewrite on deploy - the deployment script itself can overwrite settings as it is deployed to configure the environment it is deploying to. Option 1: Inject bootstrap settings into the index.htmlThis was my first attempt at solving the problem. I added a comment in the index.html and created an MVC endpoint to load the index.html file, replace the comment with a script block to create a settings object and return the updated html page. It was good for keeping the number of requests down, but it felt a bit hacky. Option 2: A separate bootstrap script fileThis approach was inspired by this post. The basic idea is to pull a separate self-executing script that contains our bootstrap settings from the index.html. 123456789101112131415&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;My Awesome Angular app&lt;/title&gt; &lt;base href=&quot;/&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;!-- Load environment variables --&gt; &lt;script src=&quot;assets/bootstrap.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;app-root&gt;&lt;/app-root&gt; &lt;/body&gt;&lt;/html&gt; Next, create the bootstrap.js file in your assets folder. It should look something like this:123456(function (window) &#123; window.bootstrapSettings = &#123; apiUrl: 'https://localhost:44384', production: false, &#125;;&#125;(this)); When the angular app loads, we now have a bootstrap object available to pull settings from. In this case, I can reference window.bootstrapSettings.apiUrl to find my api location, but I’m trying to use environment.apiUrl. Next, we need to update environment.ts to bring in the bootstrap settings. 1234export const environment = Object.assign(&#123; production: false, &#125;, (window as any).bootstrapSettings); At this point, we can build once and serve from different static sites by simply applying a different assets/bootstrap.js file with the new settings during deployment. This is good, but we’re serving from dotnet core, so we can do better. (If you’re using node, the idea is not much different). The basic idea is to avoid serving the static bootstrap file and instead, send a bootstrap file based on our appsettings file, which we can easily override from our environment (web app, container, etc) using the middleware below. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class EnvironmentBootstrap&#123; public string apiUrl &#123; get; set; &#125;&#125;public static class EnvironmentBootstrapExtensions&#123; public static IApplicationBuilder UseEnvironmentBootstrap( this IApplicationBuilder builder, string path) &#123; return builder.UseMiddleware&lt;EnvironmentBootstrapMiddleware&gt;(path); &#125;&#125;public class EnvironmentBootstrapMiddleware&#123; private readonly RequestDelegate _next; private readonly EnvironmentBootstrap _environment; private readonly string _endpointPath; public EnvironmentBootstrapMiddleware( RequestDelegate next, IOptions&lt;EnvironmentBootstrap&gt; options, string path) &#123; _next = next; _endpointPath = path; _environment = options.Value; &#125; public async Task Invoke(HttpContext httpContext) &#123; // Short circuit on request for bootstrap.js if (httpContext.Request.Path .Equals(_endpointPath, StringComparison.Ordinal)) &#123; httpContext.Response.ContentType = \"application/javascript\"; await httpContext.Response.WriteAsync( \"(function (window) &#123; window.bootstrapSettings = \" + JsonConvert.SerializeObject(_environment) + \";&#125;(this));\"); &#125; else // Pass to next item in the pipeline await _next.Invoke(httpContext); &#125;&#125; Finally, activate the pipeline in the Startup.cs file:1234567891011121314151617181920public class Startup&#123; public void ConfigureServices(IServiceCollection services) &#123; // ... services.Configure&lt;EnvironmentBootstrap&gt;( Configuration.GetSection(\"client\")); // ... &#125; public void Configure(IApplicationBuilder app) &#123; // ... // Bootstrap the bootstrap.js file ahead of UseStaticFiles app.UseEnvironmentBootstrap(\"/assets/bootstrap.js\"); app.UseStaticFiles(); app.UseSpaStaticFiles(); // ... &#125;&#125; That’s it! The project can now be built once and deployed to different environments, with angular client environment settings available to be configured from the environment itself. For an Azure Web app, set an Application Setting ‘client:apiUrl’ to override the client’s apiUrl environment setting. What do you think? Is there a better solution? What do you like or dislike about this approach?","categories":[],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"http://anthonyison.com/tags/dotnet/"},{"name":"angular","slug":"angular","permalink":"http://anthonyison.com/tags/angular/"}]},{"title":"Automatic HTTPS on Kubernetes","slug":"automatic-https-on-kubernetes","date":"2019-02-16T14:00:00.000Z","updated":"2019-05-02T22:30:30.959Z","comments":true,"path":"automatic-https-on-kubernetes/","link":"","permalink":"http://anthonyison.com/automatic-https-on-kubernetes/","excerpt":"This post starts with a slight regret that I didn’t get Ghost running on a Web App. One of the brilliant parts of a Web App is that you can force all requests over HTTPS with the click of a button. Of course, I’d still need to organise a certificate for my domain. Hold on, let me stop and back up a minute.","text":"This post starts with a slight regret that I didn’t get Ghost running on a Web App. One of the brilliant parts of a Web App is that you can force all requests over HTTPS with the click of a button. Of course, I’d still need to organise a certificate for my domain. Hold on, let me stop and back up a minute. What the heck is this HTTPS and certificate stuff? Basically, HTTPS will guarantee that the communication between the client and server can’t be read or changed by anyone between the client and server. So, usernames and passwords are safe to send. While that’s important, it’s probably more important that your pages cannot be changed either. It’s a bit like a message written in code with the king’s seal. Since the code (HTTPS) is known to you and the king, you know it cannot be read. The seal (certificate) proves the authenticity. As I set out on this adventure, it looks like I need cert-manager and the best way to install this appears to be to use helm, which I installed with Chocolatey. choco install kubernetes-helmhelm initFirst stepsWe are going to install cert-manager which will perform all of the magic of fetching certificates and storing them for use in our various services. We need to set up the config for cert-manager, so that we can provide the link to Lets Encrypt. Save the following in a file, say issuer.yaml, and run ‘kubectl apply -f issuer.yaml’ to apply. (Make sure you update with your email first!) 1234567891011apiVersion: certmanager.k8s.io/v1alpha1kind: ClusterIssuermetadata: name: letsencrypt-prodspec: acme: server: https://acme-v02.api.letsencrypt.org/directory email: youremail@gmail.com privateKeySecretRef: name: letsencrypt-prod http01: &#123;&#125; Installing cert managerkubectl apply -f \\ https://raw.githubusercontent.com/jetstack/cert-manager/release-0.6/deploy/manifests/00-crds.yaml helm install –name cert-manager –namespace ingress \\ –set ingressShim.defaultIssuerName=letsencrypt-prod –set ingressShim.defaultIssuerKind=ClusterIssuer stable/cert-managerI ran into issues installing cert-manager with a ‘cluster-admin’ not found error. I found instructions on this page4 which helped me create a cluster admin role, create a service account and assign tiller to it. Installing nginx-ingressThe next step is to configure an Ingress to manage the TLS endpoint, that is to manage my HTTPS endpoint with certificate connected to my domain. Without this step, I found I could set up my Ingress entry, but the address would stay empty. helm install stable/nginx-ingress \\ –name nginx \\ –set rbac.create=true \\ –namespace ingressOnce installed, I can see a LoadBalancer entry which has my External IP on it. Update the ServiceIn the previous post, we set the service up as a LoadBalancer type. We don’t need that any more since we have a new IP on our LoadBalancer nginx-ingress service. Update the service.yaml and change LoadBalancer to a NodePort and run ‘kubectl apply -f service.yaml’. This will make sure we can only access our service through our TLS ingress service. Generate Certificate and Ingress for ServiceApply the following updates to the kubernetes cluster. 12345678910111213141516171819202122232425262728293031323334353637apiVersion: extensions/v1beta1kind: Ingressmetadata: name: anthonyison-ingress annotations: kubernetes.io/ingress.class: nginx certmanager.k8s.io/cluster-issuer: letsencrypt-prodspec: tls: - hosts: - anthonyison.com secretName: anthonyison-crt rules: - host: anthonyison.com http: paths: - path: / backend: serviceName: anthonyison servicePort: 80apiVersion: certmanager.k8s.io/v1alpha1kind: Certificatemetadata: name: anthonyison-crtspec: secretName: anthonyison-crt dnsNames: - anthonyison.com acme: config: - http01: ingressClass: nginx domains: - anthonyison.com issuerRef: name: letsencrypt-prod kind: ClusterIssuer That’s it! Hit your domain and confirm that https is working. You should be able to click on the padlock in the address bar and click on Certificate to see the details. You should see a certificate issued by Lets Encrypt to your domain name. So, I started off with some regret that I wasn’t running in a Web App. While it took quite a while to work through many of the issues that showed up along the way, it is actually pretty easy once it’s set up, and furthermore, I don’t have to think about my certificates ever again. I think maybe it’s not as bad as I thought. No regrets, right? References:","categories":[],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://anthonyison.com/tags/kubernetes/"}]},{"title":"Running Ghost on Kubernetes on Azure","slug":"running-ghost-on-kubernetes-on-azure","date":"2019-01-15T14:00:00.000Z","updated":"2019-05-02T11:59:16.151Z","comments":true,"path":"running-ghost-on-kubernetes-on-azure/","link":"","permalink":"http://anthonyison.com/running-ghost-on-kubernetes-on-azure/","excerpt":"In my previous post, I was looking into a few options for running my blog. I think at this time, I’m going to keep it on Azure because I can run it for free. I suspect I would make a different choice if not for my bonus credits. I will need some benchmark figures to choose a provider, however kubernetes should give me the platform I need to change in the future if necessary.","text":"In my previous post, I was looking into a few options for running my blog. I think at this time, I’m going to keep it on Azure because I can run it for free. I suspect I would make a different choice if not for my bonus credits. I will need some benchmark figures to choose a provider, however kubernetes should give me the platform I need to change in the future if necessary. I have a basic level of understanding of how kubernetes hangs together and would love to hear your feedback if you would do things differently. The basic idea is to run a ghost container and provide persistent storage for the content. In the future, I would like to use nginx to reverse proxy incoming traffic and to provide HTTPS for my site. I have used AKS to generate a kubernetes cluster and my kubectl is configured to connect to it. First, I need to configure my storage. For this, I use a yaml file. 1234567891011apiVersion: v1kind: PersistentVolumeClaimmetadata: name: anthonyison-contentspec: accessModes: - ReadWriteOnce resources: requests: storage: 5Gi storageClassName: default Using kubectl apply -f volume.yaml we can generate the volume claim to be used in the next step. Next, we will generate a deployment for the the ghost container, linking it to the anthonyison-content volume. 1234567891011121314151617181920212223242526272829303132apiVersion: apps/v1beta1kind: Deploymentmetadata: name: anthonyison labels: app: anthonyisonspec: replicas: 1 selector: matchLabels: app: anthonyison template: metadata: labels: app: anthonyison spec: containers: - name: anthonyison image: ghost:2.9.1-alpine imagePullPolicy: Always ports: - containerPort: 2368 env: - name: url value: http://anthonyison.com volumeMounts: - mountPath: /var/lib/ghost/content name: content volumes: - name: content persistentVolumeClaim: claimName: anthonyison-content So now we have a ghost container running in Kubernetes with an external mounted volume for storing content. However, it’s not exposed as yet. We do that with a Service. The service.yaml is below. 123456789101112apiVersion: v1kind: Servicemetadata: name: anthonyisonspec: type: LoadBalancer selector: app: anthonyison ports: - protocol: TCP port: 80 targetPort: 2368 And that’s actually all there is to it. By running kubectl get services you can see the External IP. If you put that in the browser, you will go to the new blog. Better still, put the IP into your DNS A record, and your domain name will direct to the new site.","categories":[],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://anthonyison.com/tags/kubernetes/"},{"name":"ghost","slug":"ghost","permalink":"http://anthonyison.com/tags/ghost/"},{"name":"azure","slug":"azure","permalink":"http://anthonyison.com/tags/azure/"}]},{"title":"Creating a blog with Ghost","slug":"creating-a-blog-with-ghost","date":"2019-01-07T14:00:00.000Z","updated":"2019-05-02T12:03:25.185Z","comments":true,"path":"creating-a-blog-with-ghost/","link":"","permalink":"http://anthonyison.com/creating-a-blog-with-ghost/","excerpt":"There seems to come a time in a software developer’s life where you look at creating a blog. It’s that time for me. I want a place where I can write up some of my experiments for later reference, and if that can help others along the way, all the better!","text":"There seems to come a time in a software developer’s life where you look at creating a blog. It’s that time for me. I want a place where I can write up some of my experiments for later reference, and if that can help others along the way, all the better! Considerations I don’t want to pay anything. I really don’t want to break the bank with this project. If I can pay nothing, I will. This puts Azure squarely in the front seat because I have $70 a month to spend there. Easy to use. I don’t want to spend ages messing with this project, or debugging issues. Broad application / reusable. It would be great if this thing can be used for more than just this blog. If I can host other sites or blogs on the same infrastructure, that would be kinda handy. Preferably something I want to learn. Cause, you know. What’s the point otherwise? At first, I had thought I’d be using Wordpress and I wasn’t really looking forward to that. On the upside, there are wordpress containers around and I was pretty keen to run it in a container. After a quick email with Thiago, I started looking at Ghost. Once I knew it was there, I noticed that many of the blogs I read, including Troy Hunt, are powered by Ghost. With little more than that meagre planning, it was time to get started. Attempt 1: Azure Web appsFirstly, I needed a place to host it. I’m an Azure guy, so I started there. It seemed to be straight forward enough. A ghost container, wrapped in a Web App, running on Linux, volume mapped to a Azure File storage. I ran it locally and it worked perfectly. Once installed on Azure, I found the database just wouldn’t load up correctly, giving Migration errors, saying that the database was locked. First attempt foiled! Attempt 2: Google GKEMy next attempt was to spin it up on GKE on to Google cloud. Kubernetes seemed to be a bit of overkill for what I was trying, but Google made that super easy, and it pretty much “just worked”. That left me with the question, what about AKS on Azure? Attempt 3: Azure AKSI’ve never created an AKS cluster. I mean, I’ve wanted to. Who hasn’t? The thing is, I’ve never actually clicked the Go button. So, I guess it’s time. It was easy enough to configure as well and then I clicked Create and waited. I waited and then I waited some more. I went looking for any events showing that something was happening, but couldn’t see anything. So I tried again and this time, it worked. It spun up easy enough and with minor changes to the PersistentVolumeClaim, it just worked as well, albeit it a bit slower than GKE, which was odd because I had double the resources on Azure. So, now what?Alright, so now I seem to be on the kubernetes train. Even writing it now, it seems kinda crazy to spin up a kubernetes cluster to run a blog that is probably only going to have me as traffic. But it is expandable. There are a couple of sites I want to host. They’re currently in containers on Azure Web apps, but should move across easy enough. I’m still not sure of cost. I will run both solutions for a couple of days and have a look at what charges come through. I hadn’t planned to move from Azure at this time. That’s where I have the most experience. Next steps Run some performance and pricing measures to compare GKE vs AKS and decide where my blog will stay. Write up the technical steps for creating the blog. Enable the site to run HTTPS with Let’s Encrypt certificates.","categories":[],"tags":[{"name":"ghost","slug":"ghost","permalink":"http://anthonyison.com/tags/ghost/"}]}]}